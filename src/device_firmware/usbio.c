/**********************************************************************
*                                                                     *
*    Filename:      usbio.c                                           *
*    Date:                                                            *
*    File Version:                                                    *
*                                                                     *
*    Author:        Peter Jakab <el@jap.hu>                           *
*                   http://jap.hu/electronic/                         *
*                                                                     *
*    Based on the USB framework written by Bradley A. Minch           *
*    http://pe.ece.olin.edu/ece/projects.html                         *
*                                                                     *
*    USB descriptor is generated by USBDescriptorKitchen (0.3)        *
*    written by Daniel Mack                                           *
*    http://github.com/zonque/USBDescriptorKitchen/                   *
*                                                                     *
***********************************************************************
* NOTES
* USB digital I/O extender
*
***********************************************************************/
// HISTORY
//
// 004-20120212 based on usbio.asm version 003
//              rewrite in C
//
// 005-20120212 control commands implemented
// 007-20140807 add serial number to USB descriptor
// 
#include <p18cxxx.h>
#include "usb_defs.h"
#include "commands.h"

// configword 0x300000
        #pragma config CPUDIV = NOCLKDIV, USBDIV = OFF, FOSC = HS, PLLEN = ON, PCLKEN = ON, FCMEN = OFF, IESO = OFF
// configword 0x300002
        #pragma config PWRTEN = ON, BOREN = OFF, BORV = 30
// configword 0x300003
        #pragma config WDTEN = OFF, WDTPS = 32768
// configword 0x300005
        #pragma config HFOFST = OFF, MCLRE = ON
// configword 0x300006
        #pragma config STVREN = ON, LVP = OFF, XINST = OFF
// configword 0x300008
        #pragma config CP0 = OFF, CP1 = OFF
// configword 0x300009
        #pragma config CPB = OFF, CPD = OFF
// configword 0x30000a 
        #pragma config WRT0 = OFF, WRT1 = OFF
// configword 0x30000b 
        #pragma config WRTB = OFF, WRTC = OFF, WRTD = OFF
// configword 0x30000c 
        #pragma config EBTR0 = OFF, EBTR1 = OFF
// configword 0x30000d
        #pragma config EBTRB = OFF

#pragma udata
BUFDESC USB_buffer_desc;
unsigned char USB_buffer_data[8];
unsigned char USB_error_flags;
unsigned char USB_curr_config;
unsigned char USB_device_status;
unsigned char USB_dev_req;
unsigned char USB_address_pending;
unsigned char rom *USB_desc_ptr;
unsigned char USB_bytes_left;
unsigned char USB_packet_length;
unsigned char USB_USTAT;
unsigned char USB_USWSTAT;
unsigned char COUNTER_L;
unsigned char COUNTER_H;

#pragma romdata

/***************************************************************************
   AUTOMATICALLY GENERATED by USBDescriptorKitchen (0.3)
   See http://github.com/zonque/USBDescriptorKitchen/
   for more information about the tool that was used to generate this descriptor.
 ***************************************************************************/

rom const unsigned char Device[] = {
  /* Device*/
  0x12,                       /* bLength (Size of this descriptor in bytes) */
  DEVICE,                     /* bDescriptorType (DEVICE Descriptor Type) */
  0x00, 0x02,                 /* bcdUSB (USB Specification Release Number in Binary-Coded Decimal) ("2.0") (512) */
  0xff,                       /* bDeviceClass (Class code (assigned by the USB-IF).) ("Vendor specific") */
  0x00,                       /* bDeviceSubClass (Subclass code (assigned by the USB-IF).) */
  0x00,                       /* bDeviceProtocol (Protocol code (assigned by the USB-IF).) */
  MAX_PACKET_SIZE,            /* bMaxPacketSize0 (Maximum packet size for endpoint zero) ("8") */
  0xd8, 0x04,                 /* idVendor (Vendor ID (assigned by the USB-IF)) (1240) */
  0xc0, 0xf7,                 /* idProduct (Product ID (assigned by the manufacturer)) (f7c0) */
  0x07, 0x00,                 /* bcdDevice (Device release number in binary-coded decimal) (0) */
  0x01,                       /* iManufacturer */
  0x02,                       /* iProduct */
  0x03,                       /* iSerialNumber */
  NUM_CONFIGURATIONS,         /* bNumConfigurations (Number of possible configurations) */
};

rom const unsigned char Configuration_1[] = {
  /* Configuration*/
  0x09,                       /* bLength (Size of this descriptor in bytes) */
  CONFIGURATION,              /* bDescriptorType (CONFIGURATION Descriptor Type) */
  0x12, 0x00,                 /* wTotalLength (Total length of data returned for this configuration) (18) */
  NUM_INTERFACES,             /* bNumInterfaces (Number of interfaces supported by this configuration) */
  0x01,                       /* bConfigurationValue (Value to use as an argument to the SetConfiguration() request to select this configuration) */
  0x00,                       /* iConfiguration (Index of string descriptor describing this configuration) */
  0xa0,                       /* bmAttributes (Configuration characteristics) ('Remote Wakeup' = 1, 'Self-powered' = 0, 'Reserved (set to one)' = 1) */
  0x32,                       /* bMaxPower (Maximum power consumption of the USB, device. Expressed in 2 mA units) */
    /* Interface*/
    0x09,                     /* bLength (Size of this descriptor in bytes) */
    INTERFACE,                /* bDescriptorType (INTERFACE Descriptor Type) */
    0x00,                     /* bInterfaceNumber (Number of this interface. Zero-based value.) */
    0x00,                     /* bAlternateSetting (Value used to select this alternate setting) */
    0x00,                     /* bNumEndpoints (Number of endpoints used by this interface) */
    0xff,                     /* bInterfaceClass (Class code (assigned by the USB-IF).) ("Vendor specific") */
    0x00,                     /* bInterfaceSubClass (Subclass code (assigned by the USB-IF).) ("0") */
    0xff,                     /* bInterfaceProtocol (Protocol code (assigned by the USB).) */
    0x00,                     /* iInterface (Index of string descriptor describing this interface) */
};

rom const unsigned char StringZero_1[] = {
  /* StringZero*/
  0x04,                       /* bLength (Size of this descriptor in bytes) */
  STRING,                       /* bDescriptorType (STRING Descriptor Type) */
  0x09, 0x04,                 /* wLANGID(0) ("English (United States)") (1033) */
};

rom const unsigned char String_1[] = {
  /* String*/
  0x30,                       /* bLength (Size of this descriptor in bytes) */
  STRING,                     /* bDescriptorType (STRING Descriptor Type) */
  0x50, 0x00, 0x65, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x4a, 0x00, 0x61, 0x00, 
   0x6b, 0x00, 0x61, 0x00, 0x62, 0x00, 0x2c, 0x00, 0x20, 0x00, 0x6a, 0x00, 0x61, 0x00, 0x70, 0x00, 
   0x2e, 0x00, 0x68, 0x00, 0x75, 0x00, 0x2f, 0x00, 0x65, 0x00, 0x6c, 0x00, 0x2f, 0x00, /* bString ("Peter Jakab, jap.hu/el/") (0) */
};

rom const unsigned char String_2[] = {
  /* String*/
  0x1c,                       /* bLength (Size of this descriptor in bytes) */
  STRING,                     /* bDescriptorType (STRING Descriptor Type) */
  0x47, 0x00, 0x50, 0x00, 0x49, 0x00, 0x4f, 0x00, 0x20, 0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 
   0x65, 0x00, 0x6e, 0x00, 0x64, 0x00, 0x65, 0x00, 0x72, 0x00, /* bString ("GPIO extender") (0) */
};

rom const unsigned char String_3[] = {
  /* String*/
  0x12,                       /* bLength (Size of this descriptor in bytes) */
  STRING,                     /* bDescriptorType (STRING Descriptor Type) */
  0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00, 
   /* bString ("01234567") (0) */
};

void ServiceUSB(void);

#pragma interrupt itrh
#pragma code interrupt = 0x08
void itrh(void)
{
   ServiceUSB();
}

#pragma code
void InitUSB(void) {
	UIE = 0x00;					// mask all USB interrupts
	UIR = 0x00;					// clear all USB interrupt flags
	UCFG = 0x14; // full-speed instead of: 0x10;				// configure USB for low-speed transfers and to use the on-chip transciever and pull-up resistor
	UCON = 0x08;				// enable the USB module and its supporting circuitry
	USB_curr_config = 0x00;
	USB_USWSTAT = 0x00;			// default to powered state
	USB_device_status = 0x01;
	USB_dev_req = NO_REQUEST;	// No device requests in process
	while (UCONbits.SE0);		// wait for the first SE0 to end

	// setup interrupts
	UEIR = 0; // error flags

	UEIEbits.BTSEE = 1;
	UEIEbits.BTOEE = 1;
	UEIEbits.DFN8EE = 1;
	UEIEbits.CRC16EE = 1;
	UEIEbits.CRC5EE = 1;
	UEIEbits.PIDEE = 1; // error interrupts

	UIR = 0; // USB flags

	UIEbits.UERRIE = 1;
	UIEbits.SOFIE = 0;
	UIEbits.IDLEIE = 1;
	UIEbits.ACTVIE = 1;
	UIEbits.STALLIE = 1;
	UIEbits.URSTIE = 1;
	UIEbits.TRNIE = 1; // USB interrupts

	PIR2 = 0;
	PIE2bits.USBIE = 1; // enable USB interrupts
	INTCONbits.GIE = 1;
	INTCONbits.PEIE = 1; // enable interrupts
}

void ServiceUSB(void) {
	BUFDESC *buf_desc_ptr;

	PIR2 = 0; // clear USBIF

	if (UIRbits.UERRIF) {
		UEIR = 0x00;
	} else if (UIRbits.SOFIF) {
		UIRbits.SOFIF = 0;
	} else if (UIRbits.IDLEIF) {
		UIRbits.IDLEIF = 0;
		UCONbits.SUSPND = 1;
	} else if (UIRbits.ACTVIF) {
		UIRbits.ACTVIF = 0;
		UCONbits.SUSPND = 0;
	} else if (UIRbits.STALLIF) {
		UIRbits.STALLIF = 0;
	} else if (UIRbits.URSTIF) {
		USB_curr_config = 0x00;
		UIRbits.TRNIF = 0;		// clear TRNIF four times to clear out the USTAT FIFO
		UIRbits.TRNIF = 0;
		UIRbits.TRNIF = 0;
		UIRbits.TRNIF = 0;
		UEP0 = 0x00;				// clear all EP control registers to disable all endpoints
		UEP1 = 0x00;
		UEP2 = 0x00;
		UEP3 = 0x00;
		UEP4 = 0x00;
		UEP5 = 0x00;
		UEP6 = 0x00;
		UEP7 = 0x00;
		BD0O.bytecount = MAX_PACKET_SIZE;
		BD0O.address = EP0_OUT_buffer;	// EP0 OUT gets a buffer
		BD0O.status = 0x88;				// set UOWN bit (USB can write)
		BD0I.address = EP0_IN_buffer;	// EP0 IN gets a buffer
		BD0I.status = 0x08;				// clear UOWN bit (MCU can write)
		UADDR = 0x00;				// set USB Address to 0
		UIR = 0x00;				// clear all the USB interrupt flags
		UEP0 = ENDPT_CONTROL;	// EP0 is a control pipe and requires an ACK
		UEIE = 0xFF;			// enable all error interrupts
		USB_USWSTAT = DEFAULT_STATE;
		USB_device_status = 0x01;	// self powered, remote wakeup disabled
	} else if (UIRbits.TRNIF) {
		buf_desc_ptr = (BUFDESC *)((unsigned char *)(&BD0O)+(USTAT&0x7C));	// mask out bits 0, 1, and 7 of USTAT for offset into the buffer descriptor table
		USB_buffer_desc.status = buf_desc_ptr->status;
		USB_buffer_desc.bytecount = buf_desc_ptr->bytecount;
		USB_buffer_desc.address = buf_desc_ptr->address;
		USB_USTAT = USTAT;		// save the USB status register
		UIRbits.TRNIF = 0;		// clear TRNIF interrupt flag
		USB_error_flags = 0x00;	// clear USB error flags
		switch (USB_buffer_desc.status&0x3C) {	// extract PID bits
			case TOKEN_SETUP:
				ProcessSetupToken();
				break;
			case TOKEN_IN:
				ProcessInToken();
				break;
			case TOKEN_OUT:
				ProcessOutToken();
		}
		if (USB_error_flags&0x01) {		// if there was a Request Error...
			BD0O.bytecount = MAX_PACKET_SIZE;	// ...get ready to receive the next Setup token...
			BD0I.status = 0x84;
			BD0O.status = 0x84;					// ...and issue a protocol stall on EP0
		}
	}
}

void ProcessSetupToken(void) {
	unsigned char n;

	for (n = 0; n<8; n++) {
		USB_buffer_data[n] = USB_buffer_desc.address[n];
	}
	BD0O.bytecount = MAX_PACKET_SIZE;	// reset the EP0 OUT byte count
	BD0I.status = 0x08;			// return the EP0 IN buffer to us (dequeue any pending requests)			
	BD0O.status = (!(USB_buffer_data[bmRequestType]&0x80) && (USB_buffer_data[wLength] || USB_buffer_data[wLengthHigh])) ? 0xC8:0x88;	// set EP0 OUT UOWN back to USB and DATA0/DATA1 packet according to the request type
	UCONbits.PKTDIS = 0;			// assuming there is nothing to dequeue, clear the packet disable bit
	USB_dev_req = NO_REQUEST;		// clear the device request in process
	switch (USB_buffer_data[bmRequestType]&0x60) {	// extract request type bits
		case STANDARD:
			StandardRequests();
			break;
		case CLASS:
			ClassRequests();
			break;
		case VENDOR:
			VendorRequests();
			break;
		default:
			USB_error_flags |= 0x01;	// set Request Error Flag
	}
}

void StandardRequests(void) {
	unsigned char *UEP;
	unsigned char n;
	BUFDESC *buf_desc_ptr;

	switch (USB_buffer_data[bRequest]) {
		case GET_STATUS:
			switch (USB_buffer_data[bmRequestType]&0x1F) {	// extract request recipient bits
				case RECIPIENT_DEVICE:
					BD0I.address[0] = USB_device_status;
					BD0I.address[1] = 0x00;
					BD0I.bytecount = 0x02;
					BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
					break;
				case RECIPIENT_INTERFACE:
					switch (USB_USWSTAT) {
						case ADDRESS_STATE:
							USB_error_flags |= 0x01;	// set Request Error Flag
							break;
						case CONFIG_STATE:
							if (USB_buffer_data[wIndex]<NUM_INTERFACES) {
								BD0I.address[0] = 0x00;
								BD0I.address[1] = 0x00;
								BD0I.bytecount = 0x02;
								BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
							} else {
								USB_error_flags |= 0x01;	// set Request Error Flag
							}
					}
					break;
				case RECIPIENT_ENDPOINT:
					switch (USB_USWSTAT) {
						case ADDRESS_STATE:
							if (!(USB_buffer_data[wIndex]&0x0F)) {	// get EP, strip off direction bit and see if it is EP0
								BD0I.address[0] = (((USB_buffer_data[wIndex]&0x80) ? BD0I.status:BD0O.status)&0x04)>>2;	// return the BSTALL bit of EP0 IN or OUT, whichever was requested
								BD0I.address[1] = 0x00;
								BD0I.bytecount = 0x02;
								BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
							} else {
								USB_error_flags |= 0x01;	// set Request Error Flag
							}
							break;
						case CONFIG_STATE:
							UEP = (unsigned char *)&UEP0;
							n = USB_buffer_data[wIndex]&0x0F;	// get EP and strip off direction bit for offset from UEP0
							buf_desc_ptr = &BD0O+((n<<1)|((USB_buffer_data[wIndex]&0x80) ? 0x01:0x00));	// compute pointer to the buffer descriptor for the specified EP
							if (UEP[n]&((USB_buffer_data[wIndex]&0x80) ? 0x02:0x04)) { // if the specified EP is enabled for transfers in the specified direction...
								BD0I.address[0] = ((buf_desc_ptr->status)&0x04)>>2;	// ...return the BSTALL bit of the specified EP
								BD0I.address[1] = 0x00;
								BD0I.bytecount = 0x02;
								BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
							} else {
								USB_error_flags |= 0x01;	// set Request Error Flag
							}
							break;
						default:
							USB_error_flags |= 0x01;	// set Request Error Flag
					}
					break;
				default:
					USB_error_flags |= 0x01;	// set Request Error Flag
			}
			break;
		case CLEAR_FEATURE:
		case SET_FEATURE:
			switch (USB_buffer_data[bmRequestType]&0x1F) {	// extract request recipient bits
				case RECIPIENT_DEVICE:
					switch (USB_buffer_data[wValue]) {
						case DEVICE_REMOTE_WAKEUP:
							if (USB_buffer_data[bRequest]==CLEAR_FEATURE)
								USB_device_status &= 0xFE;
							else
								USB_device_status |= 0x01;
							BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
							BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
							break;
						default:
							USB_error_flags |= 0x01;	// set Request Error Flag
					}
					break;
				case RECIPIENT_ENDPOINT:
					switch (USB_USWSTAT) {
						case ADDRESS_STATE:
							if (!(USB_buffer_data[wIndex]&0x0F)) {	// get EP, strip off direction bit, and see if its EP0
								BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
								BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
							} else {
								USB_error_flags |= 0x01;	// set Request Error Flag
							}
							break;
						case CONFIG_STATE:
							UEP = (unsigned char *)&UEP0;
							if (n = USB_buffer_data[wIndex]&0x0F) {	// get EP and strip off direction bit for offset from UEP0, if not EP0...
								buf_desc_ptr = &BD0O+((n<<1)|((USB_buffer_data[wIndex]&0x80) ? 0x01:0x00));	// compute pointer to the buffer descriptor for the specified EP
								if (USB_buffer_data[wIndex]&0x80) {	// if the specified EP direction is IN...
									if (UEP[n]&0x02) {	// if EPn is enabled for IN transfers...
										buf_desc_ptr->status = (USB_buffer_data[bRequest]==CLEAR_FEATURE) ? 0x00:0x84;
									} else {
										USB_error_flags |= 0x01;	// set Request Error Flag									
									}
								} else {	// ...otherwise the specified EP direction is OUT, so...
									if (UEP[n]&0x04) {	// if EPn is enabled for OUT transfers...
										buf_desc_ptr->status = (USB_buffer_data[bRequest]==CLEAR_FEATURE) ? 0x88:0x84;
									} else {
										USB_error_flags |= 0x01;	// set Request Error Flag									
									}
								}
							}
							if (!(USB_error_flags&0x01)) {	// if there was no Request Error...
								BD0I.bytecount = 0x00;
								BD0I.status = 0xC8;		// ...send packet as DATA1, set UOWN bit
							}
							break;
						default:
							USB_error_flags |= 0x01;	// set Request Error Flag
					}
					break;
				default:
					USB_error_flags |= 0x01;	// set Request Error Flag
			}
			break;
		case SET_ADDRESS:
			if (USB_buffer_data[wValue]>0x7F) {	// if new device address is illegal, send Request Error
				USB_error_flags |= 0x01;	// set Request Error Flag
			} else {
				USB_dev_req = SET_ADDRESS;	// processing a SET_ADDRESS request
				USB_address_pending = USB_buffer_data[wValue];	// save new address
				BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
				BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			}
			break;
		case GET_DESCRIPTOR:
			USB_dev_req = GET_DESCRIPTOR;	// processing a GET_DESCRIPTOR request
			switch (USB_buffer_data[wValueHigh]) {
				case DEVICE:
					USB_desc_ptr = Device;
					USB_bytes_left = USB_desc_ptr[0];
					if ((USB_buffer_data[wLengthHigh]==0x00) && (USB_buffer_data[wLength]<USB_bytes_left)) {
						USB_bytes_left = USB_buffer_data[wLength];
					}
					SendDescriptorPacket();
					break;
				case CONFIGURATION:
					switch (USB_buffer_data[wValue]) {
						case 0:
							USB_desc_ptr = Configuration_1;
							break;
						default:
							USB_error_flags |= 0x01;	// set Request Error Flag
					}
					if (!(USB_error_flags&0x01)) {
						USB_bytes_left = USB_desc_ptr[2];	// wTotalLength at an offset of 2
						if ((USB_buffer_data[wLengthHigh]==0x00) && (USB_buffer_data[wLength]<USB_bytes_left)) {
							USB_bytes_left = USB_buffer_data[wLength];
						}
						SendDescriptorPacket();
					}
					break;
				case STRING:
					switch (USB_buffer_data[wValue]) {
						case 0:
							USB_desc_ptr = StringZero_1;
							break;
						case 1:
							USB_desc_ptr = String_1;
							break;
						case 2:
							USB_desc_ptr = String_2;
							break;
						case 3:
							USB_desc_ptr = String_3;
							break;
						default:
							USB_error_flags |= 0x01;	// set Request Error Flag
					}
					if (!(USB_error_flags&0x01)) {
						USB_bytes_left = USB_desc_ptr[0];
						if ((USB_buffer_data[wLengthHigh]==0x00) && (USB_buffer_data[wLength]<USB_bytes_left)) {
							USB_bytes_left = USB_buffer_data[wLength];
						}
						SendDescriptorPacket();
					}
					break;
				default:
					USB_error_flags |= 0x01;	// set Request Error Flag
			}
			break;
		case GET_CONFIGURATION:
			BD0I.address[0] = USB_curr_config;	// copy current device configuration to EP0 IN buffer
			BD0I.bytecount = 0x01;
			BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			break;
		case SET_CONFIGURATION:
			if (USB_buffer_data[wValue]<=NUM_CONFIGURATIONS) {
				UEP1 = 0x00;	// clear all EP control registers except for EP0 to disable EP1-EP15 prior to setting configuration
				UEP2 = 0x00;
				UEP3 = 0x00;
				UEP4 = 0x00;
				UEP5 = 0x00;
				UEP6 = 0x00;
				UEP7 = 0x00;
				switch (USB_curr_config = USB_buffer_data[wValue]) {
					case 0:
						USB_USWSTAT = ADDRESS_STATE;
						break;
					default:
						USB_USWSTAT = CONFIG_STATE;
				}
				BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
				BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			} else {
				USB_error_flags |= 0x01;	// set Request Error Flag
			}
			break;
		case GET_INTERFACE:
			switch (USB_USWSTAT) {
				case CONFIG_STATE:
					if (USB_buffer_data[wIndex]<NUM_INTERFACES) {
						BD0I.address[0] = 0x00;	// always send back 0 for bAlternateSetting
						BD0I.bytecount = 0x01;
						BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
					} else {
						USB_error_flags |= 0x01;	// set Request Error Flag
					}
					break;
				default:
					USB_error_flags |= 0x01;	// set Request Error Flag
			}
			break;
		case SET_INTERFACE:
			switch (USB_USWSTAT) {
				case CONFIG_STATE:
					if (USB_buffer_data[wIndex]<NUM_INTERFACES) {
						switch (USB_buffer_data[wValue]) {
							case 0:		// currently support only bAlternateSetting of 0
								BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
								BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
								break;
							default:
								USB_error_flags |= 0x01;	// set Request Error Flag
						}
					} else {
						USB_error_flags |= 0x01;	// set Request Error Flag
					}
					break;
				default:
					USB_error_flags |= 0x01;	// set Request Error Flag
			}
			break;
		case SET_DESCRIPTOR:
		case SYNCH_FRAME:
		default:
			USB_error_flags |= 0x01;	// set Request Error Flag
	}
}

void ClassRequests(void) {
	switch (USB_buffer_data[bRequest]) {
		default:
			USB_error_flags |= 0x01;	// set Request Error Flag
	}
}

void VendorRequests(void) {
	switch (USB_buffer_data[bRequest]) {
		case SETPORT:
			LATC = USB_buffer_data[wValue];
			LATB = USB_buffer_data[wValue+1];
			BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
			BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			break;
		case SETDIR:
			TRISC = USB_buffer_data[wValue];
			TRISB = USB_buffer_data[wValue+1];
			BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
			BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			break;
		case SETBIT:
			LATC |= USB_buffer_data[wValue];
			LATB |= USB_buffer_data[wValue+1];
			BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
			BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			break;
		case CLEARBIT:
			LATC &= (~USB_buffer_data[wValue]);
			LATB &= (~USB_buffer_data[wValue+1]);
			BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
			BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			break;
		case GETPORT:
			BD0I.address[0] = PORTC;
			BD0I.address[1] = PORTB;
			BD0I.bytecount = 0x02; // set byte count to 2
			BD0I.status = 0xC8; // send packet as DATA1, set UOWN bit
			break;
		default:
			USB_error_flags |= 0x01;	// set Request Error Flag
	}
}

void ProcessInToken(void) {
	switch (USB_USTAT&0x18) {	// extract the EP bits
		case EP0:
			switch (USB_dev_req) {
				case SET_ADDRESS:
					switch (UADDR = USB_address_pending) {
						case 0:
							USB_USWSTAT = DEFAULT_STATE;
							break;
						default:
							USB_USWSTAT = ADDRESS_STATE;
					}
					break;
				case GET_DESCRIPTOR:
					SendDescriptorPacket();
					break;
			}
			break;
		case EP1:
			break;
		case EP2:
			break;
	}
}

void ProcessOutToken(void) {
	switch (USB_USTAT&0x18) {	// extract the EP bits
		case EP0:
			BD0O.bytecount = MAX_PACKET_SIZE;
			BD0O.status = 0x88;
			BD0I.bytecount = 0x00;		// set EP0 IN byte count to 0
			BD0I.status = 0xC8;		// send packet as DATA1, set UOWN bit
			break;
		case EP1:
			break;
		case EP2:
			break;
	}
}

void SendDescriptorPacket(void) {
	unsigned char n;

	if (USB_bytes_left<MAX_PACKET_SIZE) {
		USB_dev_req = NO_REQUEST;	// sending a short packet, so clear device request
		USB_packet_length = USB_bytes_left;
		USB_bytes_left = 0x00;
	} else {
		USB_packet_length = MAX_PACKET_SIZE;
		USB_bytes_left -= MAX_PACKET_SIZE;
	}
	for (n = 0; n<USB_packet_length; n++) {
		BD0I.address[n] = *USB_desc_ptr++;
	}
	BD0I.bytecount = USB_packet_length;
	BD0I.status = ((BD0I.status^0x40)&0x40)|0x88; // toggle the DATA01 bit, clear the PIDs bits, and set the UOWN and DTS bits
}

void main(void) {
	PORTA = 0x00;
	PORTB = 0x00;
	PORTC = 0x00;
	ANSEL = 0;
	ANSELH = 0;
	SLRCON = 0;
	CM1CON0 = 0;
	CM2CON0 = 0;
	TRISA = 0x00;			// setup all PORTA pins to be digital outputs
	TRISB = 0xf0;			// setup GPIO pins as digital inputs
	TRISC = 0xff;
	InitUSB();			// initialize the USB registers and serial interface engine


	// while (USB_USWSTAT!=CONFIG_STATE) {		// while the peripheral is not configured...
 	//	ServiceUSB();						// ...service USB requests
	// }

	while (USB_USWSTAT != CONFIG_STATE); // wait until the host configures the peripherial

	while (1); // loop
}
